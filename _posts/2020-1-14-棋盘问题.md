---
title:棋盘问题
categories：
-学习笔记
-算法
-简单搜索
---

## 问题概述

给定棋盘形状和棋子数量，任意两个棋子不同行不同列。

典型的dfs问题，总结一下自己写dfs常犯的错误和注意事项。

## 解题代码

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char map[8][8];//棋盘布局
int n = 0, k = 0;//棋盘&棋子
int total = 0;//方案总数
int loc[8];//第i列是否已放置
int cnt = 0;//已放置棋子

void dfs(int a)
{
	if (cnt == k) {
		total++;
		return;
	}
	else {
		if (a >= n) return;
		else {
			for (int i = 0; i < n; i++) {
				if (map[a][i] == '#' && loc[i] == 0) {
					cnt++;
					loc[i] = 1;
					dfs(a+1);
					cnt--;
					loc[i] = 0;
				}
			}
			dfs(a + 1);
		}
	}
}
int main(void)
{
	while (scanf("%d %d", &n, &k)) {
		if (n == -1 && k == -1) break;
		else {
			memset(loc,0, sizeof(loc));
			total = 0;
			cnt = 0;
			getchar();
			for (int i = 0; i < n; i++) {
				for (int j=0; j < n; j++) {
					scanf("%c", &map[i][j]);
				}
				getchar();
			}
			
			if(n<k) printf("0\n");
			else {
				dfs(0);
				printf("%d\n", total);
			}
		}
	}
}
```

## 总结

* 全局变量

  关键点就是有一个**记录某列是否有棋子**loc[]数组，一个记录放置了多少个棋子的变量cnt。

* 深搜`dfs()`

  深度优先搜索基本是利用递归完成的。
  写递归的时候首先要确定的就是跳出递归的条件：

  * 棋子全都摆好了，return。
  * 超出棋盘边界了，return。
  
* 深搜的基本思路：

  确定第一层位置，进入第二层位置，一直到结束后return回最上层。

  这里需要注意的就是在**上层调用返回后要注意还原cnt变量和loc[i]变量**。

  再就是对给定行循环遍历后(for循环结束后)，可以对列遍历，因为n和k的大小关系不确定。

